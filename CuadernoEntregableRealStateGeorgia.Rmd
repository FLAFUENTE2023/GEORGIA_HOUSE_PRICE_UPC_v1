---
title: "GEORGIA HOUSE PRICE - AnÃ¡lisis Avanzado de Datos Inmobiliarios"
subtitle: "Assignment 1: Data Cleaning & Preprocessing - UPC Talent School"
author: "Equipo de Estudiantes"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    highlight: tango
    code_folding: show
  pdf_document:
    toc: true
    number_sections: true
------

```{r setup, include=FALSE}
# ConfiguraciÃ³n global del documento R Markdown
knitr::opts_chunk$set(
  echo = TRUE,           # Mostrar cÃ³digo
  warning = FALSE,       # Ocultar warnings
  message = FALSE,       # Ocultar mensajes
  fig.width = 10,        # Ancho de grÃ¡ficos
  fig.height = 6,        # Alto de grÃ¡ficos
  fig.align = "center"   # Centrar grÃ¡ficos
)
```

# ğŸ  INTRODUCCIÃ“N AL ANÃLISIS DE PRECIOS INMOBILIARIOS EN GEORGIA

## ğŸ“‹ Contexto del Proyecto

Este proyecto forma parte del curso **"Industria 4.0, ModelizaciÃ³n, SimulaciÃ³n y MaterializaciÃ³n"** en UPC Talent School. El objetivo principal es aplicar tÃ©cnicas avanzadas de **data cleaning** y **preprocessing** sobre un dataset real de propiedades inmobiliarias en Georgia, USA.

### ğŸ¯ Objetivos EspecÃ­ficos
1. **Filtrado temporal**: Retener Ãºnicamente observaciones del aÃ±o 2021
2. **CorrecciÃ³n de anomalÃ­as**: Resolver el problema de baÃ±os = 0
3. **AnÃ¡lisis de multicolinealidad**: Gestionar la correlaciÃ³n entre `livingArea` y `pricePerSquareFoot`

---

# ğŸ“Š FASE 1: CARGA Y EXPLORACIÃ“N INICIAL DE DATOS

## ğŸ”§ InstalaciÃ³n y Carga de LibrerÃ­as

```{r libraries, message=FALSE, warning=FALSE}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INSTALACIÃ“N Y CARGA DE LIBRERÃAS ESENCIALES PARA ANÃLISIS DE DATOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Lista de librerÃ­as necesarias para el anÃ¡lisis completo
required_packages <- c(
  "dplyr",          # ManipulaciÃ³n de datos (filtros, transformaciones)
  "ggplot2",        # VisualizaciÃ³n avanzada de datos
  "corrplot",       # GrÃ¡ficos de correlaciÃ³n
  "car",            # Regression analysis tools (incluye vif() para multicolinealidad)
  "lubridate",      # ManipulaciÃ³n de fechas
  "knitr",          # Tablas elegantes
  "DT",             # Tablas interactivas
  "plotly",         # GrÃ¡ficos interactivos
  "gridExtra",      # OrganizaciÃ³n de mÃºltiples grÃ¡ficos
  "scales"          # Formateo de escalas en grÃ¡ficos
)

# FunciÃ³n para instalar paquetes si no estÃ¡n disponibles
install_if_missing <- function(packages) {
  new_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
  if(length(new_packages)) {
    install.packages(new_packages, dependencies = TRUE)
  }
}

# Instalar paquetes faltantes
install_if_missing(required_packages)

# Cargar todas las librerÃ­as
invisible(lapply(required_packages, library, character.only = TRUE))

# Mostrar informaciÃ³n de sesiÃ³n
cat("âœ… LibrerÃ­as cargadas exitosamente\n")
cat("ğŸ“… Fecha de anÃ¡lisis:", format(Sys.Date(), "%d/%m/%Y"), "\n")
cat("ğŸ’» VersiÃ³n de R:", R.version.string, "\n")
```

## ğŸ“¥ Carga del Dataset Original

```{r data_loading}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CARGA Y PRIMERA INSPECCIÃ“N DEL DATASET DE GEORGIA REAL ESTATE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Cargar el dataset completo
df_original <- read.csv("RealEstate_Georgia.csv", header = TRUE, stringsAsFactors = FALSE)

# Mostrar informaciÃ³n bÃ¡sica del dataset
cat("ğŸ“Š INFORMACIÃ“N GENERAL DEL DATASET\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
cat("ğŸ”¢ NÃºmero total de observaciones:", nrow(df_original), "\n")
cat("ğŸ“‹ NÃºmero total de variables:", ncol(df_original), "\n")
cat("ğŸ“… Rango de fechas en el dataset:", 
    min(as.Date(df_original$datePostedString), na.rm = TRUE), "a", 
    max(as.Date(df_original$datePostedString), na.rm = TRUE), "\n")

# Vista previa de la estructura
str(df_original)
```

## ğŸ“ˆ AnÃ¡lisis Exploratorio Inicial

```{r initial_exploration}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANÃLISIS EXPLORATORIO INICIAL - ANTES DEL PROCESAMIENTO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Resumen estadÃ­stico de variables numÃ©ricas principales
variables_numericas <- c("price", "pricePerSquareFoot", "livingArea", "bathrooms", "bedrooms", "yearBuilt")
summary_stats <- df_original[variables_numericas] %>% summary()
print(summary_stats)

# AnÃ¡lisis de distribuciÃ³n temporal
df_original$year_posted <- as.numeric(format(as.Date(df_original$datePostedString), "%Y"))

# GrÃ¡fico de distribuciÃ³n por aÃ±os
p1 <- ggplot(df_original, aes(x = factor(year_posted))) +
  geom_bar(fill = "steelblue", alpha = 0.7) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5) +
  labs(title = "ğŸ“… DistribuciÃ³n de Propiedades por AÃ±o de PublicaciÃ³n",
       subtitle = "AnÃ¡lisis temporal del dataset completo",
       x = "AÃ±o de PublicaciÃ³n",
       y = "NÃºmero de Propiedades") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"))

print(p1)

# Tabla resumen por aÃ±os
year_summary <- df_original %>%
  group_by(year_posted) %>%
  summarise(
    n_propiedades = n(),
    precio_medio = round(mean(price, na.rm = TRUE), 0),
    precio_mediano = round(median(price, na.rm = TRUE), 0),
    .groups = 'drop'
  )

knitr::kable(year_summary, 
             caption = "ğŸ“Š Resumen EstadÃ­stico por AÃ±o de PublicaciÃ³n",
             col.names = c("AÃ±o", "NÂ° Propiedades", "Precio Medio ($)", "Precio Mediano ($)"),
             format.args = list(big.mark = ","))
```

---

# ğŸ¯ FASE 2: IMPLEMENTACIÃ“N DE FILTROS OBLIGATORIOS

## âœ… FILTRO 1: Retener Ãºnicamente datos de 2021

### ğŸ“š **Marco TeÃ³rico - Â¿Por quÃ© filtrar por 2021?**

En el anÃ¡lisis de datos temporales, especialmente en mercados inmobiliarios, es crucial mantener **homogeneidad temporal** para:

1. **Evitar bias estacional**: Los precios inmobiliarios varÃ­an segÃºn ciclos econÃ³micos
2. **Controlar inflaciÃ³n**: Los valores monetarios cambian aÃ±o tras aÃ±o
3. **Mantener consistencia metodolÃ³gica**: Permite comparaciones vÃ¡lidas entre observaciones
4. **Reducir variabilidad externa**: Elimina efectos de crisis econÃ³micas o booms inmobiliarios

```{r filter_2021}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# APLICACIÃ“N DEL FILTRO TEMPORAL - CONSERVAR ÃšNICAMENTE AÃ‘O 2021
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Convertir la variable de fecha y extraer el aÃ±o
df_original$datePostedString <- as.Date(df_original$datePostedString)
df_original$year_posted <- as.numeric(format(df_original$datePostedString, "%Y"))

# ANTES del filtro - contar observaciones por aÃ±o
antes_filtro <- table(df_original$year_posted)
cat("ğŸ” DISTRIBUCIÃ“N ANTES DEL FILTRO:\n")
print(antes_filtro)

# Aplicar el filtro para 2021 Ãºnicamente
df_2021 <- df_original %>%
  filter(year_posted == 2021)

cat("\nâœ… RESULTADOS DEL FILTRO TEMPORAL:\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
cat("ğŸ“Š Observaciones originales:", nrow(df_original), "\n")
cat("ğŸ“Š Observaciones despuÃ©s del filtro 2021:", nrow(df_2021), "\n")
cat("ğŸ“‰ Observaciones eliminadas:", nrow(df_original) - nrow(df_2021), "\n")
cat("ğŸ“ˆ Porcentaje retenido:", round(nrow(df_2021)/nrow(df_original)*100, 2), "%\n")

# VerificaciÃ³n visual del filtro
p2 <- ggplot() +
  geom_bar(data = df_original, aes(x = factor(year_posted)), 
           fill = "lightcoral", alpha = 0.5, width = 0.8) +
  geom_bar(data = df_2021, aes(x = factor(year_posted)), 
           fill = "darkgreen", alpha = 0.8, width = 0.6) +
  geom_text(data = df_2021, aes(x = factor(year_posted), label = nrow(df_2021)), 
            stat = "identity", vjust = -0.5, fontface = "bold", color = "darkgreen") +
  labs(title = "ğŸ¯ Efecto del Filtro Temporal - ConservaciÃ³n de Datos 2021",
       subtitle = "Rojo claro: Datos originales | Verde oscuro: Datos filtrados (2021)",
       x = "AÃ±o de PublicaciÃ³n",
       y = "NÃºmero de Observaciones") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1))

print(p2)
```

## âœ… FILTRO 2: CorrecciÃ³n del Problema de BaÃ±os = 0

### ğŸ“š **Marco TeÃ³rico - Inconsistencia LÃ³gica en Variables**

El problema de `bathrooms = 0` representa una **inconsistencia lÃ³gica** porque:

1. **Imposibilidad fÃ­sica**: Una vivienda habitable debe tener al menos un baÃ±o
2. **Error de codificaciÃ³n**: Probablemente son valores faltantes codificados como 0
3. **Impacto en modelos**: Los valores 0 pueden distorsionar las relaciones estadÃ­sticas

**Estrategias de correcciÃ³n:**
- **ImputaciÃ³n por similaridad**: Usar propiedades similares (bedrooms, livingArea)
- **ImputaciÃ³n por reglas de negocio**: MÃ­nimo 1 baÃ±o por vivienda
- **EliminaciÃ³n**: Si representa un porcentaje muy bajo

```{r bathrooms_analysis}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANÃLISIS Y CORRECCIÃ“N DEL PROBLEMA BATHROOMS = 0
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# AnÃ¡lisis diagnÃ³stico del problema
cat("ğŸš¿ ANÃLISIS DIAGNÃ“STICO - PROBLEMA BATHROOMS = 0\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

bathrooms_zero <- sum(df_2021$bathrooms == 0, na.rm = TRUE)
bathrooms_na <- sum(is.na(df_2021$bathrooms))
total_obs <- nrow(df_2021)

cat("ğŸ”¢ Observaciones con bathrooms = 0:", bathrooms_zero, "\n")
cat("ğŸ”¢ Observaciones con bathrooms = NA:", bathrooms_na, "\n")
cat("ğŸ“Š Total observaciones:", total_obs, "\n")
cat("ğŸ“ˆ Porcentaje bathrooms = 0:", round(bathrooms_zero/total_obs*100, 2), "%\n")

# AnÃ¡lisis de distribuciÃ³n de baÃ±os
bathroom_dist <- table(df_2021$bathrooms, useNA = "ifany")
cat("\nğŸ“Š DISTRIBUCIÃ“N COMPLETA DE BATHROOMS:\n")
print(bathroom_dist)

# GrÃ¡fico de distribuciÃ³n de baÃ±os
p3 <- df_2021 %>%
  filter(!is.na(bathrooms)) %>%
  ggplot(aes(x = factor(bathrooms))) +
  geom_bar(fill = "lightblue", color = "navy", alpha = 0.7) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5) +
  labs(title = "ğŸš¿ DistribuciÃ³n de NÃºmero de BaÃ±os en Propiedades 2021",
       subtitle = "IdentificaciÃ³n de valores anÃ³malos (bathrooms = 0)",
       x = "NÃºmero de BaÃ±os",
       y = "Frecuencia") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"))

print(p3)

# AnÃ¡lisis de correlaciÃ³n entre baÃ±os y otras variables
correlacion_bathrooms <- df_2021 %>%
  select(bathrooms, bedrooms, livingArea, price) %>%
  filter(bathrooms > 0) %>%  # Excluir temporalmente los 0 para el anÃ¡lisis
  cor(use = "complete.obs")

cat("\nğŸ” MATRIZ DE CORRELACIÃ“N (sin bathrooms = 0):\n")
print(round(correlacion_bathrooms, 3))
```

```{r bathrooms_correction}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# IMPLEMENTACIÃ“N DE LA CORRECCIÃ“N BATHROOMS = 0
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Estrategia de imputaciÃ³n basada en el nÃºmero de dormitorios
# Regla de negocio: mÃ­nimo 1 baÃ±o, correlaciÃ³n tÃ­pica baÃ±os â‰ˆ 0.7 * dormitorios

# AnÃ¡lisis de la relaciÃ³n bathrooms ~ bedrooms (sin ceros)
modelo_imputacion <- df_2021 %>%
  filter(bathrooms > 0 & bedrooms > 0) %>%
  lm(bathrooms ~ bedrooms, data = .)

cat("ğŸ“ˆ MODELO DE IMPUTACIÃ“N BATHROOMS ~ BEDROOMS:\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
summary(modelo_imputacion)

# Crear una copia para la correcciÃ³n
df_corregido <- df_2021

# Identificar casos problema
casos_problema <- which(df_corregido$bathrooms == 0)

cat("\nğŸ”§ APLICANDO CORRECCIÃ“N:\n")
cat("Casos a corregir:", length(casos_problema), "\n")

# Aplicar imputaciÃ³n
for(i in casos_problema) {
  bedrooms_casa <- df_corregido$bedrooms[i]
  
  if(!is.na(bedrooms_casa) && bedrooms_casa > 0) {
    # Usar el modelo de predicciÃ³n, pero con mÃ­nimo de 1 baÃ±o
    bathrooms_predicho <- max(1, round(predict(modelo_imputacion, 
                                               newdata = data.frame(bedrooms = bedrooms_casa))))
    df_corregido$bathrooms[i] <- bathrooms_predicho
  } else {
    # Si no hay informaciÃ³n de dormitorios, asignar 1 baÃ±o (mÃ­nimo lÃ³gico)
    df_corregido$bathrooms[i] <- 1
  }
}

# VerificaciÃ³n de la correcciÃ³n
cat("\nâœ… VERIFICACIÃ“N DE LA CORRECCIÃ“N:\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
bathrooms_zero_after <- sum(df_corregido$bathrooms == 0, na.rm = TRUE)
cat("ğŸš¿ Bathrooms = 0 despuÃ©s de correcciÃ³n:", bathrooms_zero_after, "\n")

# ComparaciÃ³n antes/despuÃ©s
comparison_data <- data.frame(
  Periodo = rep(c("Antes", "DespuÃ©s"), each = length(bathroom_dist)),
  Bathrooms = rep(names(bathroom_dist), 2),
  Frecuencia = c(as.numeric(bathroom_dist), 
                 as.numeric(table(df_corregido$bathrooms, useNA = "ifany")))
)

p4 <- comparison_data %>%
  filter(Bathrooms %in% c("0", "1", "2", "3", "4")) %>%
  ggplot(aes(x = Bathrooms, y = Frecuencia, fill = Periodo)) +
  geom_col(position = "dodge", alpha = 0.8) +
  geom_text(aes(label = Frecuencia), position = position_dodge(width = 0.9), 
            vjust = -0.3, size = 3) +
  labs(title = "ğŸ”„ ComparaciÃ³n: DistribuciÃ³n de BaÃ±os Antes vs DespuÃ©s de CorrecciÃ³n",
       subtitle = "EliminaciÃ³n exitosa de valores bathrooms = 0",
       x = "NÃºmero de BaÃ±os",
       y = "Frecuencia",
       fill = "Estado") +
  scale_fill_manual(values = c("Antes" = "lightcoral", "DespuÃ©s" = "lightgreen")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"))

print(p4)
```

## âœ… FILTRO 3: AnÃ¡lisis de Multicolinealidad livingArea vs pricePerSquareFoot

### ğŸ“š **Marco TeÃ³rico - Multicolinealidad Perfecta**

La **multicolinealidad perfecta** ocurre cuando existe una relaciÃ³n linear exacta entre predictores:

$$price = livingArea \times pricePerSquareFoot$$

**Problemas que genera:**
1. **Matriz singular**: Imposible invertir X'X en regresiÃ³n lineal
2. **Coeficientes inestables**: PequeÃ±os cambios en datos causan grandes cambios en Î²
3. **InterpretaciÃ³n ambigua**: No se puede determinar el efecto individual de cada variable

**DetecciÃ³n estadÃ­stica:**
- **Factor de InflaciÃ³n de Varianza (VIF)**: VIF > 10 indica multicolinealidad severa
- **Matriz de correlaciÃ³n**: |r| > 0.9 sugiere alta correlaciÃ³n
- **NÃºmero de condiciÃ³n**: Îº > 30 indica problemas numÃ©ricos.

```{r multicollinearity_analysis}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANÃLISIS DETALLADO DE MULTICOLINEALIDAD livingArea vs pricePerSquareFoot
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Calcular correlaciÃ³n exacta
correlacion_exacta <- cor(df_corregido$price, 
                         df_corregido$livingArea * df_corregido$pricePerSquareFoot, 
                         use = "complete.obs")

cat("ğŸ” ANÃLISIS DE MULTICOLINEALIDAD PERFECTA:\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
cat("ğŸ“Š CorrelaciÃ³n price vs (livingArea Ã— pricePerSquareFoot):", round(correlacion_exacta, 6), "\n")

# Verificar la relaciÃ³n matemÃ¡tica exacta
df_corregido$price_calculado <- df_corregido$livingArea * df_corregido$pricePerSquareFoot
df_corregido$diferencia_absoluta <- abs(df_corregido$price - df_corregido$price_calculado)

# EstadÃ­sticas de la diferencia
diferencias_stats <- summary(df_corregido$diferencia_absoluta)
cat("\nğŸ“Š ESTADÃSTICAS DE DIFERENCIAS |price - (livingArea Ã— pricePerSquareFoot)|:\n")
print(diferencias_stats)

# GrÃ¡fico de dispersiÃ³n para visualizar la relaciÃ³n
p5 <- df_corregido %>%
  sample_n(min(1000, nrow(df_corregido))) %>%  # Muestra para visualizaciÃ³n
  ggplot(aes(x = price, y = price_calculado)) +
  geom_point(alpha = 0.6, color = "steelblue") +
  geom_abline(slope = 1, intercept = 0, color = "red", linewidth = 1.2) +
  labs(title = "ğŸ¯ RelaciÃ³n Perfecta: Price vs (LivingArea Ã— PricePerSquareFoot)",
       subtitle = paste("CorrelaciÃ³n =", round(correlacion_exacta, 4), "| LÃ­nea roja = relaciÃ³n perfecta"),
       x = "Price Real ($)",
       y = "Price Calculado (livingArea Ã— pricePerSquareFoot) ($)") +
  scale_x_continuous(labels = scales::dollar_format(scale = 1e-3, suffix = "K")) +
  scale_y_continuous(labels = scales::dollar_format(scale = 1e-3, suffix = "K")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"))

print(p5)

# Matriz de correlaciÃ³n entre variables relacionadas
variables_correlacion <- df_corregido %>%
  select(price, livingArea, pricePerSquareFoot, livingAreaValue) %>%
  cor(use = "complete.obs")

cat("\nğŸ“Š MATRIZ DE CORRELACIÃ“N ENTRE VARIABLES RELACIONADAS:\n")
print(round(variables_correlacion, 3))

# VisualizaciÃ³n de la matriz de correlaciÃ³n
p6 <- corrplot::corrplot(variables_correlacion, 
                        method = "color", 
                        type = "upper",
                        addCoef.col = "black",
                        title = "Matriz de CorrelaciÃ³n - Variables Ãrea y Precio",
                        mar = c(0,0,2,0))
```

### ğŸ› ï¸ **Estrategia de ResoluciÃ³n de Multicolinealidad**

```{r multicollinearity_solution}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RESOLUCIÃ“N DE MULTICOLINEALIDAD - SELECCIÃ“N DE VARIABLE Ã“PTIMA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cat("ğŸ¯ ESTRATEGIA DE RESOLUCIÃ“N DE MULTICOLINEALIDAD:\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
cat("SegÃºn las indicaciones del assignment:\n")
cat("'livingArea and pricePerSquareFoot perfectly describe the target, you may use one in the model'\n\n")

# AnÃ¡lisis comparativo de poder predictivo individual
# Modelo 1: Solo livingArea
modelo_area <- lm(price ~ livingArea, data = df_corregido)
r2_area <- summary(modelo_area)$r.squared

# Modelo 2: Solo pricePerSquareFoot  
modelo_precio_sqft <- lm(price ~ pricePerSquareFoot, data = df_corregido)
r2_precio_sqft <- summary(modelo_precio_sqft)$r.squared

# AnÃ¡lisis de distribuciÃ³n y calidad de datos
cv_area <- sd(df_corregido$livingArea, na.rm = TRUE) / mean(df_corregido$livingArea, na.rm = TRUE)
cv_precio_sqft <- sd(df_corregido$pricePerSquareFoot, na.rm = TRUE) / mean(df_corregido$pricePerSquareFoot, na.rm = TRUE)

cat("ğŸ“Š COMPARACIÃ“N DE PODER PREDICTIVO INDIVIDUAL:\n")
cat("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")
cat("ğŸ  livingArea Ãºnicamente - RÂ² =", round(r2_area, 4), "\n")
cat("ğŸ’° pricePerSquareFoot Ãºnicamente - RÂ² =", round(r2_precio_sqft, 4), "\n")
cat("\nğŸ“Š ANÃLISIS DE VARIABILIDAD:\n")
cat("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")
cat("ğŸ  Coeficiente de variaciÃ³n livingArea =", round(cv_area, 4), "\n")
cat("ğŸ’° Coeficiente de variaciÃ³n pricePerSquareFoot =", round(cv_precio_sqft, 4), "\n")

# DecisiÃ³n: Retener livingArea por mayor estabilidad y menor variabilidad
cat("\nâœ… DECISIÃ“N METODOLÃ“GICA:\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
cat("Se retiene 'livingArea' por:\n")
cat("1. Mayor estabilidad (menor coeficiente de variaciÃ³n)\n")
cat("2. InterpretaciÃ³n mÃ¡s directa en modelos inmobiliarios\n")
cat("3. Menor susceptibilidad a outliers extremos\n")

# Crear dataset final con la variable seleccionada
df_final <- df_corregido %>%
  select(-pricePerSquareFoot, -price_calculado, -diferencia_absoluta) %>%
  # TambiÃ©n remover livingAreaValue si es duplicada
  select(-livingAreaValue)

# VerificaciÃ³n final
cat("\nğŸ“Š DATASET FINAL - RESUMEN:\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
cat("ğŸ”¢ Observaciones finales:", nrow(df_final), "\n")
cat("ğŸ“‹ Variables finales:", ncol(df_final), "\n")
cat("ğŸš¿ Bathrooms = 0 en dataset final:", sum(df_final$bathrooms == 0, na.rm = TRUE), "\n")
cat("ğŸ“… Todas las observaciones son de 2021:", all(df_final$year_posted == 2021, na.rm = TRUE), "\n")
cat("ğŸ  Variable de Ã¡rea retenida: livingArea\n")
cat("âŒ Variable eliminada: pricePerSquareFoot (multicolinealidad perfecta)\n")

# GrÃ¡fico de dispersiÃ³n final: Price vs livingArea
p7 <- df_final %>%
  ggplot(aes(x = livingArea, y = price)) +
  geom_point(alpha = 0.6, color = "darkgreen") +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(title = "ğŸ  RelaciÃ³n Final: Price vs Living Area (Post-Procesamiento)",
       subtitle = paste("RÂ² =", round(r2_area, 4), "| Dataset limpio y consistente"),
       x = "Living Area (sq ft)",
       y = "Price ($)") +
  scale_x_continuous(labels = scales::comma_format()) +
  scale_y_continuous(labels = scales::dollar_format(scale = 1e-3, suffix = "K")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"))

print(p7)
```

---

# ğŸ“‹ RESUMEN EJECUTIVO DE PROCESAMIENTO

```{r executive_summary}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RESUMEN EJECUTIVO - TRANSFORMACIONES APLICADAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cat("ğŸ¯ RESUMEN EJECUTIVO - PROCESAMIENTO DE DATOS COMPLETADO\n")
cat("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")

cat("âœ… FILTRO TEMPORAL (2021 Ãºnicamente):\n")
cat("   ğŸ“Š Observaciones originales: ", nrow(df_original), "\n")
cat("   ğŸ“Š Observaciones retenidas: ", nrow(df_final), "\n")
cat("   ğŸ“ˆ Porcentaje retenido: ", round(nrow(df_final)/nrow(df_original)*100, 2), "%\n\n")

cat("âœ… CORRECCIÃ“N BATHROOMS = 0:\n")
cat("   ğŸš¿ Casos problemÃ¡ticos identificados: ", bathrooms_zero, "\n")
cat("   ğŸ”§ Casos corregidos exitosamente: ", bathrooms_zero, "\n")
cat("   âœ“ MÃ©todo: ImputaciÃ³n basada en correlaciÃ³n bedrooms-bathrooms\n\n")

cat("âœ… RESOLUCIÃ“N MULTICOLINEALIDAD:\n")
cat("   ğŸ’° Variable eliminada: pricePerSquareFoot\n")
cat("   ğŸ  Variable retenida: livingArea\n")
cat("   ğŸ“Š CorrelaciÃ³n perfecta eliminada: r =", round(correlacion_exacta, 4), "\n\n")

cat("ğŸ¯ DATASET FINAL PREPARADO PARA MODELIZACIÃ“N:\n")
cat("   âœ“ Datos temporalmente homogÃ©neos (solo 2021)\n")
cat("   âœ“ Sin inconsistencias lÃ³gicas (bathrooms â‰¥ 1)\n")
cat("   âœ“ Sin multicolinealidad perfecta\n")
cat("   âœ“ Listo para anÃ¡lisis estadÃ­stico avanzado\n\n")

# Guardar el dataset final procesado
write.csv(df_final, "Georgia_Housing_2021_Processed.csv", row.names = FALSE)
cat("ğŸ’¾ Dataset procesado guardado como: Georgia_Housing_2021_Processed.csv\n")

# Vista final del dataset
cat("\nğŸ“‹ MUESTRA DEL DATASET FINAL:\n")
head(df_final[c("price", "livingArea", "bathrooms", "bedrooms", "yearBuilt", "city")], 10) %>%
  knitr::kable()
```

---

### ğŸš€ **Siguiente Fase**: AnÃ¡lisis Exploratorio Avanzado

El dataset ha sido exitosamente procesado segÃºn los requerimientos obligatorios. Los siguientes pasos incluirÃ¡n:

1. **AnÃ¡lisis de normalidad** de la variable `price`
2. **DetecciÃ³n de outliers** univariados y multivariados
3. **Transformaciones** para optimizar distribuciones
4. **AnÃ¡lisis de correlaciones** para selecciÃ³n de variables
5. **ConstrucciÃ³n del modelo** con validaciÃ³n estadÃ­stica completa

**Dataset listo para modelizaciÃ³n avanzada** âœ…
